<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Fits Generalized Linear Model via Study-Level Meta-Analysis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="../../assets/R.css" />
</head><body>

<table width="100%" summary="page for ds.glmSLMA {dsBaseClient}"><tr><td>ds.glmSLMA {dsBaseClient}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Fits Generalized Linear Model via Study-Level Meta-Analysis</h2>

<h3>Description</h3>

<p>Fits a generalized linear model (GLM) on data from single or multiple sources
with pooled co-analysis across studies being based on SLMA (Study-Level Meta-Analysis).
</p>


<h3>Usage</h3>

<pre>
ds.glmSLMA(
  formula = NULL,
  family = NULL,
  offset = NULL,
  weights = NULL,
  combine.with.metafor = TRUE,
  dataName = NULL,
  checks = FALSE,
  maxit = 30,
  datasources = NULL
)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>formula</code></td>
<td>
<p>an object of class formula describing
the model to be fitted. For more information see 
<strong>Details</strong>.</p>
</td></tr>
<tr valign="top"><td><code>family</code></td>
<td>
<p>identifies the error distribution function to use in
the model.</p>
</td></tr>
<tr valign="top"><td><code>offset</code></td>
<td>
<p>a character string specifying the name of a variable to be used as
an offset.<code>ds.glmSLMA</code> does not allow an offset vector to be
written directly into the GLM formula.</p>
</td></tr>
<tr valign="top"><td><code>weights</code></td>
<td>
<p>a character string specifying the name of a variable containing
prior regression
weights for the fitting process. <code>ds.glmSLMA</code> does not allow a weights vector to be
written directly into the GLM formula.</p>
</td></tr>
<tr valign="top"><td><code>combine.with.metafor</code></td>
<td>
<p>logical. If TRUE the
estimates and standard errors for each regression coefficient are pooled across
studies using random-effects meta-analysis under maximum likelihood (ML),
restricted maximum likelihood (REML) or fixed-effects meta-analysis (FE). Default TRUE.</p>
</td></tr>
<tr valign="top"><td><code>dataName</code></td>
<td>
<p>a character string specifying the name of an (optional) data frame that contains
all of the variables in the GLM formula.</p>
</td></tr>
<tr valign="top"><td><code>checks</code></td>
<td>
<p>logical. If TRUE <code>ds.glmSLMA</code> checks the structural integrity 
of the model. Default FALSE. For more information see <strong>Details</strong>.</p>
</td></tr>
<tr valign="top"><td><code>maxit</code></td>
<td>
<p>a numeric scalar denoting the maximum number of iterations that
are permitted before <code>ds.glmSLMA</code> declares that the model has failed to converge. 
For more information see <strong>Details</strong>.</p>
</td></tr>
<tr valign="top"><td><code>datasources</code></td>
<td>
<p>a list of <code>DSConnection-class</code> objects obtained after login. 
If the <code>datasources</code> argument is not specified
the default set of connections will be used: see <code>datashield.connections_default</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ds.glmSLMA</code> specifies the structure of a Generalized Linear Model 
to be fitted separately on each study or data source. 
From a mathematical perspective, the SLMA approach (using <code>ds.glmSLMA</code>)
differs fundamentally from the usual approach using <code>ds.glm</code>
in that the latter is mathematically equivalent
to placing all individual-level data from all sources in
one central warehouse and analysing those data as one combined dataset using the
conventional <code>glm()</code> function in R. 
</p>
<p>However, although this
may sound to be preferable under all circumstances, the SLMA approach
offers key inferential advantages when there is marked heterogeneity
between sources that cannot simply be corrected with fixed-effects each reflecting a study
or centre-effect. In particular, fixed effects cannot simply be used in this way when 
there is heterogeneity in the effect that is of scientific interest.
</p>
<p>In <code>formula</code> Most shortcut notation for formulas allowed under R's standard <code>glm()</code>
function is also allowed by <code>ds.glmSLMA</code>. 
</p>
<p>Many glms can be fitted very simply using a formula such as:
</p>
<p style="text-align: center;"><i>y~a+b+c+d</i></p>
 
<p>which simply means fit a glm with <code>y</code> as the outcome variable and 
<code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> as covariates. 
By default all such models also include an intercept (regression constant) term.
</p>
<p>Instead, if you need to fit a more complex
model, for example:
</p>
<p style="text-align: center;"><i>EVENT~1+TID+SEXF*AGE.60</i></p>

<p>In the above model the outcome variable is <code>EVENT</code> 
and the  covariates 
<code>TID</code> (factor variable with level values between 1 and 6 denoting the period time), 
<code>SEXF</code> (factor variable denoting sex)
and <code>AGE.60</code> (quantitative variable representing age-60 in years). 
The term <code>1</code> forces
the model to include an intercept term, in contrast if you use the term <code>0</code> the 
intercept term is removed. The <code>*</code> symbol  between <code>SEXF</code> and <code>AGE.60</code>
means fit all possible main effects and interactions for and between those two covariates.
This takes the value 0 in all males <code>0 * AGE.60</code> 
and in females  <code>1 * AGE.60</code>. 
This model is in example 1 of  the section <strong>Examples</strong>. In this case the logarithm of 
the survival time is added as an offset (<code>log(survtime)</code>).
</p>
<p>In the <code>family</code> argument can be specified three types of models to fit:
</p>

<ul>
<li><p><code>"gaussian"</code>: conventional linear model with normally distributed errors 
</p>
</li>
<li><p><code>"binomial"</code>: conventional unconditional logistic regression model
</p>
</li>
<li><p><code>"poisson"</code>: Poisson regression model which is the most used in survival analysis. 
The model used Piecewise Exponential Regression (PER) which typically closely approximates
Cox regression in its main estimates and standard errors.
</p>
</li></ul>

<p>At present the gaussian family is automatically coupled with
an <code>identity</code> link function, the binomial family with a
<code>logistic</code> link function and the poisson family with a <code>log</code> link function. 
</p>
<p>However, if a particular user
wishes us to implement an alternative family
(e.g. <code>gamma</code>) or an alternative family/link combination (e.g. binomial with
probit) we can discuss how best to meet that request: it will almost certainly be possible,
but we may seek a small amount of funding or practical in-kind support from
the user to ensure that it can be carried out promptly.
</p>
<p>The <code>dataName</code> argument avoids you having to specify the name of the
data frame in front of each covariate in the formula. 
For example, if the data frame is called <code>DataFrame</code> you
avoid having to write: <i>DataFrame$y~DataFrame$a+DataFrame$b+DataFrame$c+DataFrame$d</i>
</p>
<p>The <code>checks</code> argument verifies that the variables in the model are all defined (exist) 
on the server-site at every study
and that they have the correct characteristics required to fit the model. 
It is suggested to make <code>checks</code> argument TRUE if an unexplained
problem in the model fit is encountered because the running process takes several minutes.
</p>
<p>In <code>maxit</code> Logistic regression and Poisson regression
models can require many iterations, particularly if the starting value of the
regression constant is far away from its actual value that the GLM
is trying to estimate. In consequence we often set <code>maxit=30</code>
but depending on the nature of the models you wish to fit, you may wish
to be alerted much more quickly than this if there is a delay in convergence, 
or you may wish to all more iterations.
</p>
<p>Server functions called: <code>glmSLMADS1</code> and <code>glmSLMADS2</code>
</p>


<h3>Value</h3>

<p>Many of the elements of the output list returned by <code>ds.glmSLMA</code> are 
equivalent to those returned by the <code>glm()</code> function in native R. However,
potentially disclosive elements
such as individual-level residuals and linear predictor values are blocked. 
In this case, only non-disclosive elements are returned from each study separately.
</p>
<p>The list of elements returned by <code>ds.glmSLMA</code> is mentioned below:
</p>
<p><code>coefficients</code>: a matrix with 5 columns:
</p>

<ul>
<li><p>First: the names of all of the regression parameters (coefficients) in the model 
</p>
</li>
<li><p>second: the estimated values 
</p>
</li>
<li><p>third: corresponding standard errors of the estimated values 
</p>
</li>
<li><p>fourth: the ratio of estimate/standard error 
</p>
</li>
<li><p>fifth: the p-value treating that as a standardised normal deviate 
</p>
</li></ul>

<p><code>family</code>: indicates the error distribution and link function used
in  GLM.
</p>
<p><code>formula</code>: model formula, see description of formula as an input parameter (above).
</p>
<p><code>df.resid</code>: the residual degrees of freedom around the model.
</p>
<p><code>deviance.resid</code>: the residual deviance around the model.
</p>
<p><code>df.null</code>: the degrees of freedom around the null model (with just an intercept).
</p>
<p><code>dev.null</code>: the deviance around the null model (with just an intercept).
</p>
<p><code>CorrMatrix</code>: the correlation matrix of parameter estimates.
</p>
<p><code>VarCovMatrix</code>: the variance-covariance matrix of parameter estimates.
</p>
<p><code>weights</code>: the vector (if any) holding regression weights.
</p>
<p><code>offset</code>: the vector (if any) holding an offset (enters glm with a
coefficient of 1.00).
</p>
<p><code>cov.scaled</code>: equivalent to <code>VarCovMatrix</code>.
</p>
<p><code>cov.unscaled</code>: equivalent to VarCovMatrix but assuming dispersion (scale)
parameter is 1.
</p>
<p><code>Nmissing</code>: the number of missing observations in the given study.
</p>
<p><code>Nvalid</code>: the number of valid (non-missing) observations in the given study.
</p>
<p><code>Ntotal</code>: the total number of observations in the given study 
(<code>Nvalid</code> + <code>Nmissing</code>).
</p>
<p><code>data</code>: equivalent to input parameter <code>dataName</code> (above).
</p>
<p><code>dispersion</code>: the estimated dispersion parameter: deviance.resid/df.resid for
a gaussian family multiple regression model, 1.00 for logistic and poisson regression.
</p>
<p><code>call</code>:  summary of key elements of the call to fit the model.
</p>
<p><code>na.action</code>:  chosen method of dealing with missing values.
Usually, <code>na.action = na.omit</code>
indicating any individual (or more strictly any &quot;observational unit&quot;)
that has any data missing that are needed for the model is
excluded from the fit, even if all the rest of the required data are present.
These required data include: the outcome variable, covariates,
or any values in a regression weight vector or offset vector. As a
side effect of this, when you include additional covariates in the model
you may exclude extra individuals from the analysis
and this can seriously distort inferential tests based on assuming models are
nested (eg likelihood ratio tests).
</p>
<p><code>iter</code>: the number of iterations required to achieve convergence
file for the <code>glm()</code> function in native R.
</p>
<p>Once the study-specific output has been returned, the function returns the
number of elements relating to the pooling of estimates across studies via
study-level meta-analysis. These are as follows:
</p>
<p><code>input.beta.matrix.for.SLMA</code>: a matrix containing the vector of coefficient
estimates from each study.
</p>
<p><code>input.se.matrix.for.SLMA</code>: a matrix containing the vector of standard error
estimates for coefficients from each study.
</p>
<p><code>SLMA.pooled.estimates</code>: a matrix containing pooled estimates for each
regression coefficient across all studies with pooling under SLMA via
random-effects meta-analysis under maximum likelihood (ML), restricted maximum
likelihood (REML) or via fixed-effects meta-analysis (FE).
</p>
<p><code>convergence.error.message</code>:  reports for each study whether the model converged.
If it did not some information about the reason for this is reported.
</p>


<h3>Author(s)</h3>

<p>DataSHIELD Development Team
</p>


<h3>Examples</h3>

<pre>
## Not run: 

 ## Version 6, for version 5 see Wiki
  # Connecting to the Opal servers
  
  require('DSI')
  require('DSOpal')
  require('dsBaseClient')
  
  # Example 1: Fitting GLM for survival analysis
  # For this analysis we need to load survival data from the server 
  
  builder &lt;- DSI::newDSLoginBuilder()
  builder$append(server = "study1", 
                 url = "http://192.168.56.100:8080/", 
                 user = "administrator", password = "datashield_test&amp;", 
                 table = "SURVIVAL.EXPAND_NO_MISSING1", driver = "OpalDriver")
  builder$append(server = "study2", 
                 url = "http://192.168.56.100:8080/", 
                 user = "administrator", password = "datashield_test&amp;", 
                 table = "SURVIVAL.EXPAND_NO_MISSING2", driver = "OpalDriver")
  builder$append(server = "study3",
                 url = "http://192.168.56.100:8080/", 
                 user = "administrator", password = "datashield_test&amp;", 
                 table = "SURVIVAL.EXPAND_NO_MISSING3", driver = "OpalDriver")
  logindata &lt;- builder$build()
  
  # Log onto the remote Opal training servers
  connections &lt;- DSI::datashield.login(logins = logindata, assign = TRUE, symbol = "D") 
  
  # Fit the GLM 
  
  # make sure that the outcome is numeric 
  ds.asNumeric(x.name = "D$cens",
               newobj = "EVENT",
               datasources = connections)
               
  # convert time id variable to a factor 
               
  ds.asFactor(input.var.name = "D$time.id",
              newobj = "TID",
              datasources = connections)
              
  # create in the server-side the log(survtime) variable
         
  ds.log(x = "D$survtime",
         newobj = "log.surv",
         datasources = connections)
  
  ds.glmSLMA(formula = EVENT ~ 1 + TID + female * age.60,
         data = "D",
         family = "poisson", 
         offset = "log.surv",
         weights = NULL,
         checks = FALSE,
         maxit = 20,
         datasources = connections)
         
  # Clear the Datashield R sessions and logout
  datashield.logout(connections) 
  
  # Example 2: run a logistic regression without interaction
  # For this example we are going to load another type of data  
  
  builder &lt;- DSI::newDSLoginBuilder()
  builder$append(server = "study1", 
                 url = "http://192.168.56.100:8080/", 
                 user = "administrator", password = "datashield_test&amp;", 
                 table = "CNSIM.CNSIM1", driver = "OpalDriver")
  builder$append(server = "study2", 
                 url = "http://192.168.56.100:8080/", 
                 user = "administrator", password = "datashield_test&amp;", 
                 table = "CNSIM.CNSIM2", driver = "OpalDriver")
  builder$append(server = "study3",
                 url = "http://192.168.56.100:8080/", 
                 user = "administrator", password = "datashield_test&amp;", 
                 table = "CNSIM.CNSIM3", driver = "OpalDriver")
  logindata &lt;- builder$build()
  
  # Log onto the remote Opal training servers
  connections &lt;- DSI::datashield.login(logins = logindata, assign = TRUE, symbol = "D") 
  
  # Fit the logistic regression model

  mod &lt;- ds.glmSLMA(formula = "DIS_DIAB~GENDER+PM_BMI_CONTINUOUS+LAB_HDL",
                data = "D",
                family = "binomial",
                datasources = connections)
                
  mod #visualize the results of the model

# Example 3: fit a standard Gaussian linear model with an interaction
# We are using the same data as in example 2. It is not necessary to
# connect again to the server 

mod &lt;- ds.glmSLMA(formula = "PM_BMI_CONTINUOUS~DIS_DIAB*GENDER+LAB_HDL",
              data = "D",
              family = "gaussian",
              datasources = connections)
mod

# Clear the Datashield R sessions and logout
datashield.logout(connections) 

## End(Not run)

</pre>

<hr /><div style="text-align: center;">[Package <em>dsBaseClient</em> version 6.0.1 ]</div>
</body></html>
